//! Another builder macro-based generator with its own idioms.
//!
//! "[Ma√ßon](https://fr.wiktionary.org/wiki/ma%C3%A7on#Nom_commun_2)" is French translation for "[builder](https://www.wordreference.com/enfr/builder)"
//!
//! ### Usage
//!
//! ```
//! #[macro_use] extern crate macon;
//!
//! #[derive(Builder)]
//! struct MyType {
//!   integer: i32,
//!   string: String,
//!   optional: Option<String>,
//! }
//!
//! let _mytype: MyType = MyType::builder()
//!     .integer(42)
//!     .string("foobar")
//!     .build();
//! ```
//!
//! * adds a builder struct (`<TargetStruct>Builder`)
//! * build struct implements [`Default`]
//! * adds a `builder()` function to target struct to initialize a new builder
//! * each target struct field can be set with function of same name and parameter of same type
//! * use `build()` function to create new target struct instance
//! * any unset field will make `build()` call not compile (default)
//! * setter argument is generic over [`Into`]
//! * [`Option`] fields are not mandatory. And setters use wrapped type.
//!
//! ### Settings
//!
//! Settings are set using `#[builder()]` attribute.
//!
//! #### struct
//!
//! * **`mode=<value>`** <br/>
//! Change builder and associated `build()` function behavior. Supported values: [`Typestate`](#typestate-pattern-default) (_default_), [`Panic`](#panic-on-build) or [`Result`](#result-on-build).
//!
//! * **`Option=!`** <br/>
//! Disable automatic [`Option`] detection for whole struct. See ["`Option` fields"](#option-fields).
//!
//! * **`Default=!`** <br/>
//! Disable automatic [`Default`] derive detection for struct. See ["`Default` struct"](#default-struct).
//!
//! * **`Default`** <br/>
//! Enforce [`Default`] support for struct. See ["`Default` struct"](#default-struct).
//!
//! #### field
//!
//! * **`Option=!`** <br/>
//! Disable automatic [`Option`] detection for given field. Generated setter will rely on declared field type. See ["`Option` fields"](#option-fields).
//!
//! * **`Option=WrappedType`** <br/>
//! Enforce [`Option`] support for given field. Generated setter will rely on `WrappedType`. See ["`Option` fields"](#option-fields).
//!
//! ### Features
//!
//! For any feature, you can find blueprints in [`./tests` directory][tests] showing code generated by macro.
//!
//! #### Typestate pattern (default)
//!
//! Blueprint: [`blueprint_typestate.rs`][blueprint_typestate.rs]
//!
//! By default, builder rely on typestate pattern. It means state is encoded in type (using generics). Applicable functions are implemented
//! (callable) only when state (type) matches:
//!
//! * Build function `build()` when all properties has been set
//! * Each property setter function as long as property haven't been set
//!
//! Optionally, you can set it explictly:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! #[builder(mode=Typestate)]
//! struct MyType {
//!   integer: i32,
//!   string: String,
//! }
//!
//! ```
//!
//! #### Panic on `build()`
//!
//! Blueprint: [`blueprint_panic.rs`][blueprint_panic.rs]
//!
//! By default, builder rely on typestate pattern to avoid misconfiguration by adding compilation constraint. You can switch to a builder
//! that just panic when misconfigured:
//!
//! ```should_panic
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! #[builder(mode=Panic)]
//! struct MyType {
//!   integer: i32,
//!   string: String,
//! }
//!
//! let _mytype: MyType = MyType::builder()
//!     .integer(42)
//!     .build();
//! ```
//!
//! #### Result on `build()`
//!
//! Blueprint: [`blueprint_result.rs`][blueprint_result.rs]
//!
//! By default, builder rely on typestate pattern to avoid misconfiguration by adding compilation constraint. You can switch to a builder
//! that returns a [`Result`]:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! #[builder(mode=Result)]
//! struct MyType {
//!   integer: i32,
//!   string: String,
//! }
//!
//! let myTypeResult: Result<MyType,String> = MyType::builder()
//!     .integer(42)
//!     .build();
//!
//! assert!(myTypeResult.is_err());
//! ```
//!
//! #### Tuple
//!
//! Blueprints:
//! * [`blueprint_typestate_tuple.rs`][blueprint_typestate_tuple.rs]
//! * [`blueprint_panic_tuple.rs`][blueprint_panic_tuple.rs]
//! * [`blueprint_result_tuple.rs`][blueprint_result_tuple.rs]
//!
//! A tuple is a struct with unamed fields. Then `set<ordinal>()` is used as setter:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! struct MyTuple(
//!   i32,
//!   Option<String>,
//!   String,
//! );
//!
//! let _mytuple: MyTuple = MyTuple::builder()
//!     .set0(42)
//!     .set2(String::from("foobar"))
//!     .build();
//! ```
//!
//! Only for [`Typestate` mode](#typestate-pattern-default), you can chain `set()/none()`-calls to assign values in order:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! # #[derive(Builder)]
//! # struct MyTuple(
//! #   i32,
//! #   Option<String>,
//! #   String,
//! # );
//! let _mytuple: MyTuple = MyTuple::builder()
//!     .set(42)
//!     .none()
//!     .set(String::from("foobar"))
//!     .build();
//! ```
//!
//! #### `Into` argument
//!
//! Setter function argument is generic over [`Into`] to ease conversion (especially for `&str`):
//!
//! ```
//! # #[macro_use] extern crate macon;
//! # #[derive(Builder)]
//! # struct MyTuple(
//! #   String,
//! # );
//! let _mytuple: MyTuple = MyTuple::builder()
//!     .set("foobar")
//!     .build();
//! ```
//!
//! #### Implement `Into`
//!
//! Builders implement [`Into`] for target type (and reverse [`From`] also). Except for `Result` mode which uses [`TryInto`] / [`TryFrom`].
//!
//! ```
//! # #[macro_use] extern crate macon;
//! # #[derive(Builder)]
//! # struct MyStruct {
//! #   value: String,
//! # };
//! let _mytuple: MyStruct = MyStruct::builder()
//!     .value("foobar")
//!     .into();
//! ```
//!
//! #### `Option` fields
//!
//! As their name suggests, [`Option`] fields are facultative: you can build instance without setting them explicitly.
//!
//! Setter argument are still generic over [`Into`] but for wrapped type. No need to wrap into an [`Option`]:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! struct WithOptional {
//!   mandatory: String,
//!   optional: Option<String>,
//! }
//!
//! let built = WithOptional::builder()
//!   .optional("optional value")
//!   .mandatory("some value")
//!   .build();
//!
//! assert_eq!(Some(String::from("optional value")), built.optional);
//! ```
//!
//! You can set them explicitly to [`None`](https://doc.rust-lang.org/core/option/enum.Option.html#variant.None) with `<field>_none`:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! pub struct WithOptional {
//!   mandatory: String,
//!   optional: Option<String>,
//! }
//!
//! let built = WithOptional::builder()
//!   .optional_none()
//!   .mandatory("some value")
//!   .build();
//!
//! assert_eq!(None, built.optional);
//! ```
//!
//! <div class="warning">
//!
//! Note: In order to detect optional fields, field type **name** must match:
//!
//! * `core::option::Option`
//! * `::core::option::Option`
//! * `std::option::Option`
//! * `::std::option::Option`
//! * `Option`
//!
//! </div>
//!
//! You can disable [`Option`] support by using `#[builder(Option=!)]` at struct or field level:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder)]
//! #[builder(Option=!)]
//! struct DisableOptionStruct {
//!   optional: Option<String>,
//! }
//!
//! let built = DisableOptionStruct::builder()
//!   .optional(Some(String::from("mandatory value")))
//!   .build();
//!
//! assert_eq!(Some(String::from("mandatory value")), built.optional);
//! ```
//!
//! If you use an alias, use `#[builder(Option=<WrappedType>)]` at field level to enable [`Option`] support:
//!
//! ```
//! # #[macro_use] extern crate macon;
//! type OptString = Option<String>;
//! #[derive(Builder)]
//! struct AliasedOptionStruct {
//!   #[builder(Option=String)]
//!   optional: OptString,
//! }
//!
//! let built = AliasedOptionStruct::builder()
//!   .optional("aliased value")
//!   .build();
//!
//! assert_eq!(Some(String::from("aliased value")), built.optional);
//! ```
//!
//! #### `Default` struct
//!
//! Blueprints:
//! * [`blueprint_typestate_tuple.rs`][blueprint_typestate_tuple.rs]
//! * [`blueprint_panic_tuple.rs`][blueprint_panic_tuple.rs]
//! * [`blueprint_result_tuple.rs`][blueprint_result_tuple.rs]
//!
//! If struct derives [`Default`], all fields are then optional and values are kept from default instance:
//!
//! <div class="warning">
//!
//! Note: In order to detect [`Default`] derive, `Builder` derive attribute must be placed before other derive attributes.
//!
//! </div>
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder,)]
//! #[derive(Default,PartialEq,Debug,)]
//! struct DeriveDefaultStruct {
//!   integer: usize,
//!   string: String,
//!   optional: Option<String>,
//! }
//!
//! let built = DeriveDefaultStruct::builder()
//!   .build();
//!
//! assert_eq!(
//!   DeriveDefaultStruct {
//!     integer: 0,
//!     string: String::from(""),
//!     optional: None,
//!   },
//!   built,
//! );
//! ```
//!
//! In case [`Default`] derive detection is undesired, you can disable it with `#[builder(Default=!)]`.
//!
//! On the other hand, if have your own [`Default`] implementation, you can add `#[builder(Default)]` to enable support.
//!
//! ```
//! # #[macro_use] extern crate macon;
//! #[derive(Builder,)]
//! #[derive(PartialEq,Debug,)]
//! #[builder(Default,)]
//! struct CustomDefaultStruct {
//!   integer: usize,
//!   string: String,
//!   optional: Option<String>,
//! }
//!
//! impl Default for CustomDefaultStruct {
//!     fn default() -> Self {
//!         CustomDefaultStruct {
//!             integer: 42,
//!             string: String::from("plop!"),
//!             optional: Some(String::from("some")),
//!         }
//!     }
//! }
//!
//! let built = CustomDefaultStruct::builder()
//!   .build();
//!
//! assert_eq!(
//!   CustomDefaultStruct {
//!     integer: 42,
//!     string: String::from("plop!"),
//!     optional: Some(String::from("some")),
//!   },
//!   built,
//! );
//! ```
//!
//! You can keep default value (from default built instance) explicitly with `<field>_keep` (or `keep` for ordered setter):
//!
//! ```
//! # #[macro_use] extern crate macon;
//! # #[derive(Builder,)]
//! # #[derive(PartialEq,Debug,)]
//! # #[builder(Default,)]
//! # struct CustomDefaultStruct {
//! #  integer: usize,
//! #  string: String,
//! #  optional: Option<String>,
//! # }
//! #
//! # impl Default for CustomDefaultStruct {
//! #     fn default() -> Self {
//! #         CustomDefaultStruct {
//! #             integer: 42,
//! #             string: String::from("plop!"),
//! #             optional: Some(String::from("some")),
//! #         }
//! #     }
//! # }
//! let built = CustomDefaultStruct::builder()
//!   .integer_keep()
//!   .string("overriden")
//!   .optional_none()
//!   .build();
//!
//! assert_eq!(
//!   CustomDefaultStruct {
//!     integer: 42,
//!     string: String::from("overriden"),
//!     optional: None,
//!   },
//!   built,
//! );
//! ```
//!
//!
//! [tests]: https://github.com/loganmzz/macon-rs/tree/main/tests
//! [blueprint_panic.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_panic.rs
//! [blueprint_panic_default.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_panic_default.rs
//! [blueprint_panic_tuple.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_panic_tuple.rs
//! [blueprint_result.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_result.rs
//! [blueprint_result_default.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_result_default.rs
//! [blueprint_result_tuple.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_result_tuple.rs
//! [blueprint_typestate.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_typestate.rs
//! [blueprint_typestate_default.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_typestate_default.rs
//! [blueprint_typestate_tuple.rs]: https://github.com/loganmzz/macon-rs/blob/main/tests/blueprint_typestate_tuple.rs
//!

use syn::{
    parse_macro_input,
    DeriveInput,
};

mod model;
mod generators;

/// Macro entrypoint generating builder:
///
/// * `impl` block to add `builder()` function to target struct
/// * builder struct
/// * `impl` block(s) for generated builder struct
///     * fluent field setters
///     * final `build()` function
#[proc_macro_derive(Builder, attributes(builder))]
pub fn builder_macro_derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let builder = model::Builder::from_input(input).unwrap();
    let generator: Box<dyn generators::Generator> = builder.into();
    let value = generator.all();
    // eprintln!("{:#?}", value);
    proc_macro::TokenStream::from(value)
}
